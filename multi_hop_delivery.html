<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Hop Delivery Planning System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            color: #333;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 40px;
            animation: fadeIn 1s ease-out;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .subtitle {
            font-size: 1.1em;
            color: #6c757d;
            font-weight: 400;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 24px;
            margin-bottom: 40px;
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            border: 1px solid #e9ecef;
            transition: all 0.2s ease;
        }

        .card:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            transform: translateY(-2px);
        }

        .card h2 {
            color: #2c3e50;
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: -0.3px;
        }

        .icon {
            font-size: 1.3em;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }

        .stat-value {
            font-size: 1.6em;
            font-weight: 700;
            color: #2c3e50;
            letter-spacing: -0.5px;
        }

        .stat-label {
            font-size: 0.85em;
            color: #6c757d;
            margin-top: 4px;
            font-weight: 500;
        }

        .route-visualization {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            border: 1px solid #e9ecef;
            margin-bottom: 40px;
            position: relative;
        }

        .route-visualization h2 {
            color: #2c3e50;
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: -0.3px;
        }

        #routeCanvas {
            width: 100%;
            height: 500px;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            cursor: grab;
            background: #fafbfc;
        }

        #routeCanvas:active {
            cursor: grabbing;
        }

        .visualization-controls {
            position: absolute;
            top: 70px;
            left: 24px;
            display: flex;
            gap: 8px;
            z-index: 10;
            flex-wrap: wrap;
        }

        .viz-button {
            background: white;
            border: 1px solid #e9ecef;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            color: #495057;
        }

        .viz-button:hover {
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        .viz-button.active {
            background: #2c3e50;
            color: white;
            border-color: #2c3e50;
        }

        .control-panel {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            border: 1px solid #e9ecef;
            margin-bottom: 40px;
        }

        .control-panel h2 {
            color: #2c3e50;
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: -0.3px;
        }

        .control-group {
            margin-bottom: 24px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #495057;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            max-width: 300px;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #2c3e50;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: #1a252f;
        }

        button {
            background: #2c3e50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        button:hover {
            background: #1a252f;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .driver-list {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            border: 1px solid #e9ecef;
        }

        .driver-list h2 {
            color: #2c3e50;
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: -0.3px;
        }

        .driver-item {
            background: #fafbfc;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.15s ease;
            border: 1px solid #e9ecef;
        }

        .driver-item:hover {
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        .driver-info {
            flex: 1;
        }

        .driver-name {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 6px;
            font-size: 1em;
        }

        .driver-stats {
            display: flex;
            gap: 24px;
            font-size: 0.85em;
            color: #6c757d;
        }

        .fatigue-bar {
            width: 180px;
            height: 24px;
            background: #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .fatigue-fill {
            height: 100%;
            transition: width 0.8s ease;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .fatigue-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .fatigue-low {
            background: #28a745;
        }

        .fatigue-medium {
            background: #ffc107;
        }

        .fatigue-high {
            background: #dc3545;
        }

        .vehicle-type {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 0.75em;
            font-weight: 600;
            margin-left: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .vehicle-bike {
            background: #e7f3ff;
            color: #0066cc;
        }

        .vehicle-scooter {
            background: #fff4e6;
            color: #ff6b00;
        }

        .vehicle-van {
            background: #f3e8ff;
            color: #7c3aed;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 16px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
            border: 1px solid #e9ecef;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            border-left: 4px solid #28a745;
        }

        .notification.warning {
            border-left: 4px solid #ffc107;
        }

        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 2em;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            #routeCanvas {
                height: 350px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>üöÄ Dynamic Multi-Hop Delivery Planning</h1>
            <p class="subtitle">Intelligent Route Optimization with Driver Well-being</p>
        </header>

        <div class="dashboard">
            <div class="card pulse">
                <h2><span class="icon">üìä</span> System Overview</h2>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="activeDeliveries">0</div>
                        <div class="stat-label">Active Deliveries</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalDrivers">0</div>
                        <div class="stat-label">Active Drivers</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgDeliveryTime">0</div>
                        <div class="stat-label">Avg. Delivery Time</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="efficiencyScore">0%</div>
                        <div class="stat-label">System Efficiency</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2><span class="icon">üö≤</span> Vehicle Distribution</h2>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="bikesActive">0</div>
                        <div class="stat-label">Bikes Active</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="scootersActive">0</div>
                        <div class="stat-label">Scooters Active</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="vansActive">0</div>
                        <div class="stat-label">Vans Active</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="handoffPoints">0</div>
                        <div class="stat-label">Handoff Points</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2><span class="icon">‚ù§Ô∏è</span> Driver Well-being</h2>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="avgFatigue">0%</div>
                        <div class="stat-label">Avg. Fatigue Level</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="restingDrivers">0</div>
                        <div class="stat-label">Drivers Resting</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="routeDifficulty">0</div>
                        <div class="stat-label">Avg. Route Difficulty</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="wellbeingScore">0%</div>
                        <div class="stat-label">Well-being Score</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="route-visualization">
            <h2><span class="icon">üó∫Ô∏è</span> Live Route Visualization</h2>
            <div class="visualization-controls">
                <button class="viz-button active" onclick="toggleVisualization('all')">All Routes</button>
                <button class="viz-button" onclick="toggleVisualization('active')">Active Only</button>
                <button class="viz-button" onclick="toggleVisualization('priority')">High Priority</button>
                <button class="viz-button" onclick="clearOldDeliveries()">Clear Completed</button>
            </div>
            <canvas id="routeCanvas"></canvas>
        </div>

        <div class="control-panel">
            <h2><span class="icon">üéÆ</span> Simulation Controls</h2>
            <div class="control-group">
                <button onclick="simulation.generateNewDeliveries()">üì¶ Generate New Deliveries</button>
                <button onclick="simulation.optimizeRoutes()">üîÑ Optimize Routes</button>
                <button onclick="simulation.toggleSimulation()">‚ñ∂Ô∏è Start/Stop Simulation</button>
                <button onclick="simulation.resetSimulation()">üîÑ Reset System</button>
            </div>
            <div class="control-group">
                <label for="deliveryVolume">Delivery Volume:</label>
                <input type="range" id="deliveryVolume" min="10" max="100" value="30"
                    onchange="updateDeliveryVolume(this.value)">
                <span id="volumeValue">30</span> deliveries/hour
            </div>
            <div class="control-group">
                <label for="congestionLevel">Traffic Congestion:</label>
                <input type="range" id="congestionLevel" min="0" max="100" value="50"
                    onchange="updateCongestion(this.value)">
                <span id="congestionValue">50</span>%
            </div>
        </div>

        <div class="driver-list">
            <h2><span class="icon">üë•</span> Driver Status</h2>
            <div id="driverListContainer"></div>
        </div>
    </div>

    <div class="notification" id="notification">
        <p id="notificationText"></p>
    </div>

    <script>
        // Multi-Hop Delivery Planning System
        class DeliverySystem {
            constructor() {
                this.drivers = [];
                this.deliveries = [];
                this.handoffPoints = [];
                this.routes = [];
                this.isRunning = false;
                this.congestionLevel = 50;
                this.deliveryVolume = 30;
                this.visualizationMode = 'all';
                this.canvas = document.getElementById('routeCanvas');
                this.ctx = this.canvas.getContext('2d');

                // Pan and zoom properties
                this.viewOffset = { x: 0, y: 0 };
                this.scale = 1;
                this.isDragging = false;
                this.lastMousePos = { x: 0, y: 0 };

                this.setupCanvas();
                this.initializeSystem();
                this.setupCanvasInteraction();
            }

            setupCanvas() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;

                // Handle window resize
                window.addEventListener('resize', () => {
                    this.canvas.width = this.canvas.offsetWidth;
                    this.canvas.height = this.canvas.offsetHeight;
                    this.drawRoutes();
                });
            }

            setupCanvasInteraction() {
                // Mouse events for panning
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.lastMousePos = {
                        x: e.offsetX,
                        y: e.offsetY
                    };
                    this.canvas.style.cursor = 'grabbing';
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const dx = e.offsetX - this.lastMousePos.x;
                        const dy = e.offsetY - this.lastMousePos.y;

                        this.viewOffset.x += dx;
                        this.viewOffset.y += dy;

                        this.lastMousePos = {
                            x: e.offsetX,
                            y: e.offsetY
                        };

                        this.drawRoutes();
                    }
                });

                this.canvas.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'grab';
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'grab';
                });

                // Mouse wheel for zooming
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomSpeed = 0.1;
                    const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;

                    const newScale = Math.max(0.5, Math.min(2, this.scale + delta));

                    // Zoom towards mouse position
                    const mouseX = e.offsetX;
                    const mouseY = e.offsetY;

                    const scaleChange = newScale / this.scale;

                    this.viewOffset.x = mouseX - (mouseX - this.viewOffset.x) * scaleChange;
                    this.viewOffset.y = mouseY - (mouseY - this.viewOffset.y) * scaleChange;

                    this.scale = newScale;
                    this.drawRoutes();
                });

                // Touch events for mobile
                let touchStart = null;

                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (e.touches.length === 1) {
                        this.isDragging = true;
                        touchStart = {
                            x: e.touches[0].clientX,
                            y: e.touches[0].clientY
                        };
                    }
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.isDragging && e.touches.length === 1) {
                        const dx = e.touches[0].clientX - touchStart.x;
                        const dy = e.touches[0].clientY - touchStart.y;

                        this.viewOffset.x += dx;
                        this.viewOffset.y += dy;

                        touchStart = {
                            x: e.touches[0].clientX,
                            y: e.touches[0].clientY
                        };

                        this.drawRoutes();
                    }
                });

                this.canvas.addEventListener('touchend', () => {
                    this.isDragging = false;
                });
            }

            // Transform coordinates based on pan and zoom
            transformPoint(x, y) {
                return {
                    x: x * this.scale + this.viewOffset.x,
                    y: y * this.scale + this.viewOffset.y
                };
            }

            initializeSystem() {
                // Initialize drivers with different vehicle types
                const vehicleTypes = ['bike', 'scooter', 'van'];
                const names = ['Alex', 'Jordan', 'Sam', 'Riley', 'Casey', 'Morgan', 'Taylor', 'Jamie'];

                // Create a grid-like distribution for better spacing
                const rows = 2;
                const cols = 4;
                const xSpacing = (this.canvas.width - 200) / (cols - 1);
                const ySpacing = (this.canvas.height - 200) / (rows - 1);

                for (let i = 0; i < 8; i++) {
                    const row = Math.floor(i / cols);
                    const col = i % cols;

                    this.drivers.push({
                        id: i,
                        name: names[i],
                        vehicle: vehicleTypes[i % 3],
                        position: {
                            x: 100 + col * xSpacing + (Math.random() - 0.5) * 50,
                            y: 100 + row * ySpacing + (Math.random() - 0.5) * 50
                        },
                        fatigue: Math.random() * 20 + 10, // Start with low fatigue
                        deliveriesCompleted: 0,
                        currentRoute: null,
                        speed: vehicleTypes[i % 3] === 'bike' ? 1.5 : vehicleTypes[i % 3] === 'scooter' ? 2.5 : 3.5,
                        capacity: vehicleTypes[i % 3] === 'bike' ? 5 : vehicleTypes[i % 3] === 'scooter' ? 10 : 20,
                        lastFatigueUpdate: Date.now()
                    });
                }

                // Initialize handoff points in a better distributed pattern
                const hubPositions = [
                    { x: this.canvas.width * 0.25, y: this.canvas.height * 0.25 },
                    { x: this.canvas.width * 0.75, y: this.canvas.height * 0.25 },
                    { x: this.canvas.width * 0.5, y: this.canvas.height * 0.5 },
                    { x: this.canvas.width * 0.25, y: this.canvas.height * 0.75 },
                    { x: this.canvas.width * 0.75, y: this.canvas.height * 0.75 }
                ];

                for (let i = 0; i < 5; i++) {
                    this.handoffPoints.push({
                        id: i,
                        position: hubPositions[i],
                        type: 'transfer_hub'
                    });
                }

                this.updateStats();
                this.updateDriverList();
                this.drawRoutes();
            }

            generateNewDeliveries() {
                const numDeliveries = Math.floor(this.deliveryVolume / 6);
                const margin = 50;

                for (let i = 0; i < numDeliveries; i++) {
                    const delivery = {
                        id: Date.now() + i,
                        pickup: {
                            x: margin + Math.random() * (this.canvas.width - 2 * margin),
                            y: margin + Math.random() * (this.canvas.height - 2 * margin)
                        },
                        dropoff: {
                            x: margin + Math.random() * (this.canvas.width - 2 * margin),
                            y: margin + Math.random() * (this.canvas.height - 2 * margin)
                        },
                        priority: Math.random() > 0.7 ? 'high' : 'normal',
                        weight: Math.random() * 10 + 1,
                        status: 'pending',
                        hops: []
                    };

                    this.deliveries.push(delivery);
                }

                this.showNotification('Generated ' + numDeliveries + ' new deliveries', 'success');
                this.optimizeRoutes();
            }

            optimizeRoutes() {
                // Clear existing routes
                this.routes = [];

                // Calculate route difficulty based on distance, congestion, and stairs
                const calculateRouteDifficulty = (from, to) => {
                    const distance = Math.sqrt(Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2));
                    const congestionFactor = this.congestionLevel / 100;
                    const stairsFactor = Math.random() * 0.3; // Simulated stairs/elevation
                    return distance * (1 + congestionFactor) * (1 + stairsFactor);
                };

                // Multi-hop optimization algorithm
                this.deliveries.filter(d => d.status === 'pending').forEach(delivery => {
                    const hops = [];
                    let currentPos = delivery.pickup;

                    // Determine if multi-hop is beneficial
                    const directDistance = calculateRouteDifficulty(delivery.pickup, delivery.dropoff);
                    const isHighCongestion = this.congestionLevel > 70;
                    const isLongDistance = directDistance > this.canvas.width / 2;

                    if ((isHighCongestion || isLongDistance) && Math.random() > 0.3) {
                        // Find optimal handoff point
                        const nearestHub = this.handoffPoints.reduce((nearest, hub) => {
                            const dist1 = calculateRouteDifficulty(currentPos, hub.position);
                            const dist2 = calculateRouteDifficulty(currentPos, nearest.position);
                            return dist1 < dist2 ? hub : nearest;
                        });

                        hops.push({
                            from: currentPos,
                            to: nearestHub.position,
                            vehicle: 'bike',
                            difficulty: calculateRouteDifficulty(currentPos, nearestHub.position)
                        });

                        currentPos = nearestHub.position;
                    }

                    // Final hop to destination
                    hops.push({
                        from: currentPos,
                        to: delivery.dropoff,
                        vehicle: directDistance > this.canvas.width / 3 ? 'van' : 'scooter',
                        difficulty: calculateRouteDifficulty(currentPos, delivery.dropoff)
                    });

                    delivery.hops = hops;
                    this.assignDeliveryToDriver(delivery);
                });

                this.drawRoutes();
                this.updateStats();
                this.showNotification('Routes optimized with multi-hop planning', 'success');
            }

            assignDeliveryToDriver(delivery) {
                // Find best driver based on fatigue, vehicle type, and proximity
                const suitableDrivers = this.drivers.filter(driver => {
                    return driver.fatigue < 70 && !driver.currentRoute;
                });

                if (suitableDrivers.length === 0) {
                    this.showNotification('All drivers are fatigued. Please allow rest time.', 'warning');
                    return;
                }

                const bestDriver = suitableDrivers.reduce((best, driver) => {
                    const fatigueScore = 100 - driver.fatigue;
                    const distanceScore = 100 - (Math.sqrt(
                        Math.pow(driver.position.x - delivery.pickup.x, 2) +
                        Math.pow(driver.position.y - delivery.pickup.y, 2)
                    ) / this.canvas.width * 100);
                    const vehicleScore = delivery.hops[0].vehicle === driver.vehicle ? 20 : 0;

                    const totalScore = fatigueScore * 0.4 + distanceScore * 0.4 + vehicleScore * 0.2;

                    return totalScore > (best.score || 0) ? { driver, score: totalScore } : best;
                }, {}).driver;

                if (bestDriver) {
                    bestDriver.currentRoute = delivery;
                    delivery.status = 'assigned';
                    delivery.assignedDriver = bestDriver.id;
                }
            }

            updateDriverPosition() {
                this.drivers.forEach(driver => {
                    if (driver.currentRoute && driver.currentRoute.status === 'assigned') {
                        const target = driver.currentRoute.pickup;
                        const dx = target.x - driver.position.x;
                        const dy = target.y - driver.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 5) {
                            driver.position.x += (dx / distance) * driver.speed;
                            driver.position.y += (dy / distance) * driver.speed;

                            // Update fatigue based on route difficulty
                            const routeDifficulty = driver.currentRoute.hops[0].difficulty;
                            driver.fatigue += routeDifficulty * 0.001;
                            driver.fatigue = Math.min(driver.fatigue, 100);
                        } else {
                            // Delivery completed
                            driver.deliveriesCompleted++;
                            driver.currentRoute.status = 'completed';
                            driver.currentRoute = null;

                            // Rest if too fatigued
                            if (driver.fatigue > 80) {
                                setTimeout(() => {
                                    driver.fatigue *= 0.7;
                                }, 5000);
                            }
                        }
                    } else if (driver.fatigue > 0.1) {
                        // Natural fatigue recovery when idle
                        driver.fatigue *= 0.995;
                    }
                });
            }

            drawRoutes() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Save context state
                this.ctx.save();

                // Apply transformations
                this.ctx.translate(this.viewOffset.x, this.viewOffset.y);
                this.ctx.scale(this.scale, this.scale);

                // Draw grid for better spatial reference
                this.drawGrid();

                // Draw zones if congestion is high
                if (this.congestionLevel > 60) {
                    this.drawCongestionZones();
                }

                // Draw handoff points with labels
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = 'rgba(0,0,0,0.2)';
                this.handoffPoints.forEach((hub, index) => {
                    // Hub glow effect
                    this.ctx.beginPath();
                    this.ctx.arc(hub.position.x, hub.position.y, 25, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'rgba(255, 152, 0, 0.1)';
                    this.ctx.fill();

                    // Hub circle
                    this.ctx.beginPath();
                    this.ctx.arc(hub.position.x, hub.position.y, 18, 0, Math.PI * 2);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#ff9800';
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();

                    // Hub icon
                    this.ctx.fillStyle = '#ff9800';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('H' + (index + 1), hub.position.x, hub.position.y);
                });
                this.ctx.shadowBlur = 0;

                // Group and draw active routes only
                const activeDeliveries = this.deliveries.filter(d =>
                    d.status === 'assigned' && d.assignedDriver !== undefined
                );

                // Draw routes with better visibility
                activeDeliveries.forEach(delivery => {
                    const driver = this.drivers.find(d => d.id === delivery.assignedDriver);
                    if (!driver) return;

                    this.ctx.save();
                    this.ctx.globalAlpha = 0.7;

                    // Draw route path
                    this.ctx.beginPath();
                    this.ctx.moveTo(driver.position.x, driver.position.y);
                    this.ctx.lineTo(delivery.pickup.x, delivery.pickup.y);

                    if (delivery.hops.length > 1) {
                        delivery.hops.forEach(hop => {
                            this.ctx.lineTo(hop.to.x, hop.to.y);
                        });
                    } else {
                        this.ctx.lineTo(delivery.dropoff.x, delivery.dropoff.y);
                    }

                    // Route styling based on priority
                    if (delivery.priority === 'high') {
                        this.ctx.strokeStyle = '#e91e63';
                        this.ctx.lineWidth = 4;
                        this.ctx.setLineDash([10, 5]);
                    } else {
                        this.ctx.strokeStyle = '#2196f3';
                        this.ctx.lineWidth = 3;
                        this.ctx.setLineDash([8, 8]);
                    }

                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    this.ctx.restore();

                    // Draw pickup point
                    this.drawDeliveryPoint(delivery.pickup.x, delivery.pickup.y, 'pickup', delivery.priority);

                    // Draw dropoff point
                    this.drawDeliveryPoint(delivery.dropoff.x, delivery.dropoff.y, 'dropoff', delivery.priority);
                });

                // Draw pending deliveries with lower opacity
                const pendingDeliveries = this.deliveries.filter(d => d.status === 'pending').slice(0, 10);
                this.ctx.save();
                this.ctx.globalAlpha = 0.3;
                pendingDeliveries.forEach(delivery => {
                    this.drawDeliveryPoint(delivery.pickup.x, delivery.pickup.y, 'pickup', 'pending');
                    this.drawDeliveryPoint(delivery.dropoff.x, delivery.dropoff.y, 'dropoff', 'pending');
                });
                this.ctx.restore();

                // Draw drivers with better visibility
                this.drawDrivers();

                // Restore context state
                this.ctx.restore();

                // Draw legend (not affected by transformations)
                this.drawLegend();

                // Draw zoom/pan indicators
                this.drawControls();
            }

            drawControls() {
                // Zoom level indicator
                this.ctx.save();
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(`Zoom: ${Math.round(this.scale * 100)}%`, 10, this.canvas.height - 40);

                // Reset view button
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.fillRect(10, this.canvas.height - 30, 80, 25);
                this.ctx.strokeStyle = '#ccc';
                this.ctx.strokeRect(10, this.canvas.height - 30, 80, 25);

                this.ctx.fillStyle = '#333';
                this.ctx.font = '11px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Reset View', 50, this.canvas.height - 13);
                this.ctx.restore();

                // Handle reset view click
                if (!this.resetViewHandler) {
                    this.resetViewHandler = (e) => {
                        const rect = this.canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;

                        if (x >= 10 && x <= 90 && y >= this.canvas.height - 30 && y <= this.canvas.height - 5) {
                            this.viewOffset = { x: 0, y: 0 };
                            this.scale = 1;
                            this.drawRoutes();
                        }
                    };
                    this.canvas.addEventListener('click', this.resetViewHandler);
                }
            }

            drawGrid() {
                this.ctx.save();
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.lineWidth = 1;

                const gridSize = 50;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }

                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
                this.ctx.restore();
            }

            drawCongestionZones() {
                this.ctx.save();
                const gradient = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 50,
                    this.canvas.width / 2, this.canvas.height / 2, 200
                );
                gradient.addColorStop(0, 'rgba(255, 87, 34, 0.15)');
                gradient.addColorStop(1, 'rgba(255, 87, 34, 0)');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();
            }

            drawDeliveryPoint(x, y, type, priority) {
                this.ctx.save();

                // Outer ring for visibility
                this.ctx.beginPath();
                this.ctx.arc(x, y, 12, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.fill();

                // Inner circle
                this.ctx.beginPath();
                this.ctx.arc(x, y, 10, 0, Math.PI * 2);

                if (type === 'pickup') {
                    this.ctx.fillStyle = priority === 'high' ? '#e91e63' :
                        priority === 'pending' ? '#9e9e9e' : '#4caf50';
                } else {
                    this.ctx.fillStyle = priority === 'high' ? '#d32f2f' :
                        priority === 'pending' ? '#757575' : '#ff5722';
                }

                this.ctx.fill();

                // Icon
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(type === 'pickup' ? '‚Üë' : '‚Üì', x, y);

                this.ctx.restore();
            }

            drawDrivers() {
                this.drivers.forEach(driver => {
                    this.ctx.save();

                    // Driver shadow for visibility
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = 'rgba(0,0,0,0.3)';

                    // Driver background circle
                    this.ctx.beginPath();
                    this.ctx.arc(driver.position.x, driver.position.y, 22, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'white';
                    this.ctx.fill();

                    // Vehicle icon
                    const vehicleEmoji = driver.vehicle === 'bike' ? 'üö≤' :
                        driver.vehicle === 'scooter' ? 'üõµ' : 'üöö';

                    this.ctx.font = '20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(vehicleEmoji, driver.position.x, driver.position.y);

                    // Fatigue indicator ring
                    const fatigueColor = driver.fatigue < 30 ? '#4caf50' :
                        driver.fatigue < 70 ? '#ff9800' : '#f44336';

                    this.ctx.beginPath();
                    this.ctx.arc(driver.position.x, driver.position.y, 25, 0, Math.PI * 2);
                    this.ctx.strokeStyle = fatigueColor;
                    this.ctx.lineWidth = 3;
                    this.ctx.globalAlpha = 0.8;
                    this.ctx.stroke();

                    // Draw driver name if not too many drivers
                    if (this.drivers.length <= 8) {
                        this.ctx.fillStyle = '#333';
                        this.ctx.font = 'bold 11px Arial';
                        this.ctx.fillText(driver.name, driver.position.x, driver.position.y + 35);
                    }

                    this.ctx.restore();
                });
            }

            drawLegend() {
                this.ctx.save();

                // Legend background
                const legendX = this.canvas.width - 180;
                const legendY = 10;

                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.fillRect(legendX, legendY, 170, 120);
                this.ctx.strokeStyle = '#ccc';
                this.ctx.strokeRect(legendX, legendY, 170, 120);

                // Legend title
                this.ctx.fillStyle = '#333';
                this.ctx.font = 'bold 12px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Legend', legendX + 10, legendY + 20);

                // Legend items
                this.ctx.font = '11px Arial';

                // Pickup point
                this.drawDeliveryPoint(legendX + 20, legendY + 40, 'pickup', 'normal');
                this.ctx.fillText('Pickup Point', legendX + 35, legendY + 40);

                // Dropoff point
                this.drawDeliveryPoint(legendX + 20, legendY + 60, 'dropoff', 'normal');
                this.ctx.fillText('Dropoff Point', legendX + 35, legendY + 60);

                // Transfer hub
                this.ctx.beginPath();
                this.ctx.arc(legendX + 20, legendY + 80, 8, 0, Math.PI * 2);
                this.ctx.fillStyle = '#ff9800';
                this.ctx.fill();
                this.ctx.fillText('Transfer Hub', legendX + 35, legendY + 80);

                // High priority
                this.ctx.beginPath();
                this.ctx.moveTo(legendX + 10, legendY + 100);
                this.ctx.lineTo(legendX + 30, legendY + 100);
                this.ctx.strokeStyle = '#e91e63';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([5, 3]);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                this.ctx.fillText('High Priority', legendX + 35, legendY + 100);

                this.ctx.restore();
            }

            updateStats() {
                document.getElementById('activeDeliveries').textContent =
                    this.deliveries.filter(d => d.status !== 'completed').length;
                document.getElementById('totalDrivers').textContent = this.drivers.length;
                document.getElementById('avgDeliveryTime').textContent =
                    Math.floor(15 + Math.random() * 10) + ' min';
                document.getElementById('efficiencyScore').textContent =
                    Math.floor(85 + Math.random() * 10) + '%';

                const vehicleCounts = this.drivers.reduce((acc, driver) => {
                    acc[driver.vehicle] = (acc[driver.vehicle] || 0) + 1;
                    return acc;
                }, {});

                document.getElementById('bikesActive').textContent = vehicleCounts.bike || 0;
                document.getElementById('scootersActive').textContent = vehicleCounts.scooter || 0;
                document.getElementById('vansActive').textContent = vehicleCounts.van || 0;
                document.getElementById('handoffPoints').textContent = this.handoffPoints.length;

                const avgFatigue = this.drivers.reduce((sum, d) => sum + d.fatigue, 0) / this.drivers.length;
                document.getElementById('avgFatigue').textContent = Math.floor(avgFatigue) + '%';
                document.getElementById('restingDrivers').textContent =
                    this.drivers.filter(d => d.fatigue > 80).length;
                document.getElementById('routeDifficulty').textContent =
                    (3.5 + Math.random()).toFixed(1);
                document.getElementById('wellbeingScore').textContent =
                    Math.floor(100 - avgFatigue * 0.8) + '%';
            }

            updateDriverList() {
                const container = document.getElementById('driverListContainer');
                container.innerHTML = '';

                this.drivers.forEach(driver => {
                    const driverEl = document.createElement('div');
                    driverEl.className = 'driver-item';

                    const fatigueClass = driver.fatigue < 30 ? 'fatigue-low' :
                        driver.fatigue < 70 ? 'fatigue-medium' : 'fatigue-high';
                    const vehicleClass = 'vehicle-' + driver.vehicle;

                    driverEl.innerHTML = `
                        <div class="driver-info">
                            <div class="driver-name">${driver.name}
                                <span class="vehicle-type ${vehicleClass}">${driver.vehicle.toUpperCase()}</span>
                            </div>
                            <div class="driver-stats">
                                <span>Deliveries: ${driver.deliveriesCompleted}</span>
                                <span>Status: ${driver.currentRoute ? 'Active' : 'Available'}</span>
                            </div>
                        </div>
                        <div class="fatigue-bar">
                            <div class="fatigue-fill ${fatigueClass}" style="width: ${driver.fatigue}%"></div>
                        </div>
                    `;

                    container.appendChild(driverEl);
                });
            }

            toggleSimulation() {
                this.isRunning = !this.isRunning;
                if (this.isRunning) {
                    this.simulationLoop();
                }
            }

            simulationLoop() {
                if (!this.isRunning) return;

                this.updateDriverPosition();
                this.drawRoutes();
                this.updateStats();
                this.updateDriverList();

                // Generate new deliveries periodically
                if (Math.random() > 0.95) {
                    this.generateNewDeliveries();
                }

                // Clean up completed deliveries more aggressively
                this.deliveries = this.deliveries.filter(d => {
                    if (d.status === 'completed') {
                        if (!d.completedAt) d.completedAt = Date.now();
                        return Date.now() - d.completedAt < 2000;
                    }
                    return true;
                });

                // Limit pending deliveries to prevent clutter
                const pendingCount = this.deliveries.filter(d => d.status === 'pending').length;
                if (pendingCount > 20) {
                    this.deliveries = this.deliveries.filter(d => d.status !== 'pending').concat(
                        this.deliveries.filter(d => d.status === 'pending').slice(-20)
                    );
                }

                requestAnimationFrame(() => this.simulationLoop());
            }

            resetSimulation() {
                this.drivers = [];
                this.deliveries = [];
                this.routes = [];
                this.isRunning = false;
                this.initializeSystem();
                this.showNotification('System reset successfully', 'success');
            }

            showNotification(message, type = 'success') {
                const notification = document.getElementById('notification');
                const notificationText = document.getElementById('notificationText');

                notification.className = 'notification show ' + type;
                notificationText.textContent = message;

                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }
        }

        // Initialize the simulation
        const simulation = new DeliverySystem();

        // Visualization controls
        let visualizationMode = 'all';

        function toggleVisualization(mode) {
            visualizationMode = mode;
            document.querySelectorAll('.viz-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            simulation.visualizationMode = mode;
            simulation.drawRoutes();
        }

        function clearOldDeliveries() {
            simulation.deliveries = simulation.deliveries.filter(d => d.status !== 'completed');
            simulation.showNotification('Cleared completed deliveries', 'success');
            simulation.drawRoutes();
        }

        // Control functions
        function updateDeliveryVolume(value) {
            simulation.deliveryVolume = parseInt(value);
            document.getElementById('volumeValue').textContent = value;
        }

        function updateCongestion(value) {
            simulation.congestionLevel = parseInt(value);
            document.getElementById('congestionValue').textContent = value;

            // Update route optimization based on congestion
            if (simulation.deliveries.length > 0) {
                simulation.optimizeRoutes();
            }
        }

        // Advanced Route Optimization Algorithm
        class RouteOptimizer {
            constructor(system) {
                this.system = system;
                this.graph = new Map();
                this.buildGraph();
            }

            buildGraph() {
                // Create a graph representation of the delivery network
                const nodes = [
                    ...this.system.handoffPoints.map(h => ({ ...h, type: 'hub' })),
                    ...this.system.deliveries.map(d => ({
                        id: 'pickup_' + d.id,
                        position: d.pickup,
                        type: 'pickup'
                    })),
                    ...this.system.deliveries.map(d => ({
                        id: 'dropoff_' + d.id,
                        position: d.dropoff,
                        type: 'dropoff'
                    }))
                ];

                nodes.forEach(node => {
                    this.graph.set(node.id, {
                        node: node,
                        edges: []
                    });
                });

                // Connect nodes based on distance and vehicle constraints
                nodes.forEach(from => {
                    nodes.forEach(to => {
                        if (from.id !== to.id) {
                            const distance = this.calculateDistance(from.position, to.position);
                            const vehicleType = this.determineOptimalVehicle(distance, from.type, to.type);

                            this.graph.get(from.id).edges.push({
                                to: to.id,
                                weight: distance,
                                vehicle: vehicleType
                            });
                        }
                    });
                });
            }

            calculateDistance(from, to) {
                return Math.sqrt(Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2));
            }

            determineOptimalVehicle(distance, fromType, toType) {
                if (distance < 100 && this.system.congestionLevel > 70) return 'bike';
                if (distance < 200) return 'scooter';
                return 'van';
            }

            findOptimalPath(from, to) {
                // Dijkstra's algorithm with multi-criteria optimization
                const distances = new Map();
                const previous = new Map();
                const unvisited = new Set(this.graph.keys());

                this.graph.forEach((_, nodeId) => {
                    distances.set(nodeId, Infinity);
                });
                distances.set(from, 0);

                while (unvisited.size > 0) {
                    let current = null;
                    let minDistance = Infinity;

                    unvisited.forEach(nodeId => {
                        if (distances.get(nodeId) < minDistance) {
                            current = nodeId;
                            minDistance = distances.get(nodeId);
                        }
                    });

                    if (!current || current === to) break;

                    unvisited.delete(current);

                    const currentNode = this.graph.get(current);
                    currentNode.edges.forEach(edge => {
                        if (unvisited.has(edge.to)) {
                            const alt = distances.get(current) + edge.weight;
                            if (alt < distances.get(edge.to)) {
                                distances.set(edge.to, alt);
                                previous.set(edge.to, { from: current, vehicle: edge.vehicle });
                            }
                        }
                    });
                }

                // Reconstruct path
                const path = [];
                let current = to;
                while (current && previous.has(current)) {
                    const prev = previous.get(current);
                    path.unshift({ from: prev.from, to: current, vehicle: prev.vehicle });
                    current = prev.from;
                }

                return path;
            }
        }

        // Driver Fatigue Management System
        class FatigueManager {
            constructor(drivers) {
                this.drivers = drivers;
                this.fatigueFactors = {
                    distance: 0.01,
                    stairs: 0.02,
                    weight: 0.015,
                    traffic: 0.008,
                    time: 0.005
                };
            }

            calculateRouteDifficulty(route) {
                let difficulty = 0;

                // Distance factor
                route.hops.forEach(hop => {
                    const distance = Math.sqrt(
                        Math.pow(hop.to.x - hop.from.x, 2) +
                        Math.pow(hop.to.y - hop.from.y, 2)
                    );
                    difficulty += distance * this.fatigueFactors.distance;
                });

                // Simulated stairs/elevation (random for demo)
                difficulty += Math.random() * 10 * this.fatigueFactors.stairs;

                // Weight factor (if carrying packages)
                difficulty += (route.weight || 5) * this.fatigueFactors.weight;

                // Traffic congestion factor
                difficulty += simulation.congestionLevel * this.fatigueFactors.traffic;

                return difficulty;
            }

            updateDriverFatigue(driver, route) {
                const routeDifficulty = this.calculateRouteDifficulty(route);
                driver.fatigue += routeDifficulty;

                // Apply vehicle-specific modifiers
                if (driver.vehicle === 'bike') {
                    driver.fatigue *= 1.2; // Bikes are more tiring
                } else if (driver.vehicle === 'van') {
                    driver.fatigue *= 0.8; // Vans are less physically demanding
                }

                driver.fatigue = Math.min(driver.fatigue, 100);

                // Trigger rest period if fatigue exceeds threshold
                if (driver.fatigue > 85) {
                    this.scheduleRest(driver);
                }
            }

            scheduleRest(driver) {
                driver.isResting = true;
                const restDuration = 5000 + (driver.fatigue - 85) * 100;

                setTimeout(() => {
                    driver.fatigue *= 0.5; // Reduce fatigue by 50% after rest
                    driver.isResting = false;
                    simulation.showNotification(`${driver.name} has finished resting`, 'success');
                }, restDuration);

                simulation.showNotification(`${driver.name} is taking a rest break`, 'warning');
            }

            getWellbeingScore() {
                const avgFatigue = this.drivers.reduce((sum, d) => sum + d.fatigue, 0) / this.drivers.length;
                const restingCount = this.drivers.filter(d => d.isResting).length;
                const overworkedCount = this.drivers.filter(d => d.fatigue > 70).length;

                return Math.max(0, 100 - avgFatigue * 0.6 - restingCount * 5 - overworkedCount * 10);
            }
        }

        // Initialize advanced systems
        const routeOptimizer = new RouteOptimizer(simulation);
        const fatigueManager = new FatigueManager(simulation.drivers);

        // Auto-start simulation after 2 seconds
        setTimeout(() => {
            simulation.generateNewDeliveries();
            simulation.toggleSimulation();
        }, 2000);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    simulation.toggleSimulation();
                    break;
                case 'g':
                    simulation.generateNewDeliveries();
                    break;
                case 'o':
                    simulation.optimizeRoutes();
                    break;
                case 'r':
                    simulation.resetSimulation();
                    break;
            }
        });

        // Show initial notification
        simulation.showNotification('System initialized. Press SPACE to start simulation', 'success');
    </script>
</body>

</html>